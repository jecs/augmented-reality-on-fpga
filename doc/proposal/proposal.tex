\documentclass{article}

\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{mathtools}

\begin{document}
\title{Project Proposal\\Augmented Reality Image Processing System}
\author{Logan P. Williams \& Jos\'{e} E. Cruz Serrall\'{e}s}
\date{November 03, 2011}
\maketitle

\section{Abstract}
% Summary of what our project will do; could be called "Introduction", "Summary of Operation", etc.

\section{Top-Level Block Diagram}
% simply the image of our block diagram; let's wrap it with a \begin{figure}\end{figure} and a \centering to make it look nice

\section{Submodules \& Division of Labor}
% 1) inputs & outputs
% 2) some indication of its complexity and level of performance
%	a) number and type of arithmetic operations
%	b) size of internal memories
%	c) required throughput
%	etc.
% 3) how the module will be tested
% 4) who will be writing the module
\subsection{NTSC Capture}
% Logan

\subsection{ZBT Memory}
% Jose
The ZBT Memory module stores three 640x480 images in ZBT RAM. ZBT RAM was chosen instead of BRAM because the data in three 640x480 RGB images vastly exceeds our BRAM capacity. These three images will be (1) the image that is currently being captured, (2) the image that was just captured and to which skew will write its pixels, and (3) the image that is currently displayed. These three images will be henceforth referred to as "capturing image", "processing image", and "displaying image", respectively. The inputs to ZBT Memory are (1) the next pixel to be written to capturing image, (2) the next pixel to be written to processing image and (3) its index, (4) the index of the next pixel to be read from processing image, (5) the index of the next pixel to be read from displaying image as requested by the VGA Write module, and (6) the set of indices of the next set of pixels to be read from displaying image as requested by the ArbiLPF module. The outputs of ZBT Memory are (1) a pulse indicating whether a pixel was written to capturing image, (2) a pulse indicating whether a pixel was written to processing image, (3) the current pixel to be read from processing image, (4) a pulse indicating that this output was updated, (5) the current pixel to be read from displaying image as requested by the VGA Write module, (6) a pulse indicating that this output was updated, (7) the current set of pixels to be read from displaying image as requested by the ArbiLPF module, and (8) a pulse indicating that this output was updated.

The three images will be split between two ZBT RAM modules; as such, the ZBT Memory module will keep track of which image is in which block and intelligently return the correct pixel for each respective image given a relative index. Every NTSC capture refresh cycle (ie, every 1/30 seconds), the ZBT Memory module will switch the current processing image to be the new displaying image, the current displaying image to be the new capturing image, and the current capturing image to be the new processing image. Thus, reads and writes will be completely mandated by submodules and no data will have to be shifted around, improving efficiency.

The single write or read per cycle constraint that is imposed by each ZBT RAM module necessitates the use of a much higher clock speed than the standard 21.175MHz used for 640x480 at 60Hz output. Therefore, the clock speed will have to be at least approximately 120MHz for appropriate latency for this module. The ArbiLPF module, the ArbiSkew module, and the Object Recognition module should be run on the order of 90MHz, because this clock frequency allows for multiplications to be executed safely and allows the computationally intensive submodules enough time to complete all of their calculations.

The ZBT Memory will be a challenge to test thoroughly. The alternation of image locations will be tested with one testbench, and small sample images. Another testbench will be written to test the interface between the two RAM blocks and all of the read and write requests that they will be receive from the other submodules. Extensive care will be taken to ensure fairness among all of the submodules when contesting the memory, ie, not module should be favored too heavily among the other submodules. With a high enough clock frequency, this contention problem should not be a big issue.

\subsection{Object Recognition}
% Logan

\subsection{ArbiLPF}
% Jose
The inputs to ArbiLPF are (1) the downsampling coefficient, (2) the index of the pixel in displayed image to be filtered given this downsampling factor, (3) the set of pixels around the filtered pixels required for filtering, and (4) the pulse from the memory module. ArbiLPF applies a two-dimensional low-pass filter to this pixel by using surrounding pixels to calculate the convolution sum. The radial cutoff frequency of this 2D filter is of \( \frac{\pi}{M} \), in order to avoid aliasing in the ArbiSkew module. The output of ArbiLPF is (1) the pixel values of the output of the lowpassed version of this image, sampled at the given index.

Based on the downsampling factor M, the filter will select a set of coefficients from a lookup table and convolve the image values with these coefficients. This table of coefficients will correspond to the coefficients of 2D extrapolations of 1D FIR Parks-McClellan filters with cutoff frequencies of \( \frac{\pi}{M} \). Due to the limited number of multipliers on the FPGA and the single-input, single-output of the RAM module, these 2D filters will be constrained to have at most 16 coefficients, which constrains the one-dimensional filters to have at most 4 coefficients. Due to these constraints, the ripple and transition width specifications of the 1D filters will have to be lax. The radial symmetry of these 2D filters will be exploited to reduce the number of required multiplications by a factor of 4, to at most 4 multiplications per color per pixel or 12 multiplications per pixel.

Due to the single-input, single-output nature of the RAM, the clock frequency of this module will have to be greater than 80MHz. Given relatively little contention from other blocks, ArbiLPF will elapse at least 9 cycles at 90MHz per pixel, yielding a latency of 0.03072 seconds or a little less than one NTSC refresh period. ArbiLPF will also have to perform roughly eight additions per cycle, but the timing constraints imposed by these additions are negligible when compared to the multiplications.

ArbiLPF will be tested by crafting a testbench module that accepts an arbitrary 640x480 image and outputs the output of the filter. Initially, an image with an impulse at the center will be used, which ideally should cause the filter to output the filter coefficients that are used. As basic functionality is tested, more complicated images will be used. Eventually, complex images will be processed both with the testbench and with MATLAB and will be compared using the 2D Fourier plots of these two outputs.

\subsection{ArbiSkew}
% Logan

\subsection{VGA Write}
% Jose

\section{External Components}
% Jose

\section{List of Goals}
% A calendar-like view of what deadlines we'll set ourselves, when everything should be operational, etc. Maybe this could be collapsed into the submodules section

\end{document}
